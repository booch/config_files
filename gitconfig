[include]
	path = ~/.gitconfig.local
[core]
	excludesfile = ~/.gitignore
[color]
	ui = auto
	diff = auto
	status = auto
	branch = auto
	interactive = auto
[color "status"]
	untracked = blue
[color "diff"]
	meta = yellow bold
[apply]
	whitespace = strip
	whitespace = nowarn
[merge]
	tool = opendiff
	summary = true
[merge "bundleinstall"]
	name = bundle install
	driver = bundle install
[merge "railsschema"]
	name = newer Rails schema version
	driver = "ruby -e '\n\
		system %(git), %(merge-file), %(--marker-size=%L), %(%A), %(%O), %(%B)\n\
		b = File.read(%(%A))\n\
		b.sub!(/^<+ .*\\nActiveRecord::Schema\\.define.:version => (\\d+). do\\n=+\\nActiveRecord::Schema\\.define.:version => (\\d+). do\\n>+ .*/) do\n\
		%(ActiveRecord::Schema.define(:version => #{[$1, $2].max}) do)\n\
		end\n\
		File.open(%(%A), %(w)) {|f| f.write(b)}\n\
		exit 1 if b.include?(%(<)*%L)'"
[help]
	autocorrect = 50  # Automatically correct misspelled git subcommands after 5 seconds.
[branch]
	autosetuprebase = always  # Make 'git pull' rebase local commits on top of newly pulled-down commits instead of merging them. (http://www.viget.com/extend/only-you-can-prevent-git-merge-commits/)
[pretty]
	oneline-details = format:%C(yellow)%h%Creset -%C(red)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset
	sha = format:%Cred%H\n
	subject = format:%s
	timeline = format:%h %an %ar - %s
[push]
	default = upstream  # Push only the current branch by default, not all branches.
[pull]
	ff = true  # Only do fast-forward merges, so we don't overwrite any local changes.
[rebase]
	autostash = true  # Automatically stash and unstash during a rebase.
[rerere]
	enabled = true  # Automatically record and replay merge conflict resolutions. (http://git-scm.com/2010/03/08/rerere.html)
	autoupdate = true  # Automatically stage any resolutions that rerere solves.
[diff]
	algorithm = histogram
	compactionHeuristic = true  # Shift hunk boundaries to hopefully make patches easier to read.
	renames = copies  # Detect copies as well as renames.
[alias]
	a = add
	aa = !git add --intent-to-add . && git add -u && git status
	ac = !git add -A && git commit
	addall = !git add --intent-to-add . && git add -u && git status
	ae = add --edit
	ai = add --interactive
	aliases = !git config --get-regexp 'alias.*' | colrm 1 6 | sed 's/[ ]/ = /' | sort
	amend = commit --amend --reset-author --reuse-message=HEAD
	anw = !git diff -U0 -w --no-color -- \"$@\" | git apply --cached --ignore-whitespace --unidiff-zero "#"
	ap = add --patch
	at = add --intent-to-add
	au = add --update
	authors = "!git log --pretty=format:%aN | sort | uniq -c | sort -rn"
	b = branch -vv
	back = checkout "-"
	bclean = "!f(){ git branch --merged master | awk '$NF !~ /master/ {print $NF}' | xargs git branch -d; }; f"
	bn = !git branch-name
	br = branch
	branch-name = !git for-each-ref --format='%(refname:short)' $(git symbolic-ref HEAD)
	branches = for-each-ref --sort=-committerdate --format=\"%(color:blue)%(authordate:relative)%(color:black)\t%(refname:strip=3)\t%(color:red)%(authorname)\" --no-merged origin/master refs/remotes
	c = commit
	ca = commit --amend
	changes=diff --name-status -r
	changed=diff --name-only
	check = diff --check
	cheddar = commit --amend -CHEAD
	cherry-lick = !sh -c 'hub checkout HEAD^{} -- && hub cherry-pick \"$@\"' _
	ci = commit -v
	clear = !git add . && git stash && git stash drop
	cm = commit --message
	co = checkout
	cob = checkout -b
	com = checkout master
	conflicted = grep --name-only --full-name '<<<<<<< HEAD'
	conflicts = grep --name-only --full-name '<<<<<<< HEAD'
	continue = rebase --continue
	contributors = shortlog --summary --numbered
	cp = cherry-pick
	cpc = cherry-pick --signoff
	create-branch = !sh -c 'git push origin HEAD:refs/heads/$1 && git fetch origin && git branch --track $1 origin/$1 && cd . && git checkout $1' -
	credit = "!f() { git commit --amend --author \"$1 <$2>\" -C HEAD; }; f"
	ctags = "!sh -c '[ -f .git/hooks/ctags ] || git init; .git/hooks/ctags' git-ctags"
	current-branch = rev-parse --abbrev-ref HEAD
	d = !"git diff-index --quiet HEAD -- || clear; git --no-pager diff --patch-with-stat"
	dc = diff --cached
	delete-branch = !sh -c 'git push origin :refs/heads/$1 && git remote prune origin && git branch -D $1' -
	delete-merged-branches = "!git branch --merged | grep -v '\\*' | xargs -n 1 git branch -d"
	delete-remote-merged-branches = "!git branch -r --merged | grep -v '\\*' | sed 's/origin\\//:/' | xargs git push origin"
	dh1 = diff HEAD~1
	di = diff
	diff-stat = diff -b --stat
	discard = checkout --
	div = divergence
	dm = "!git branch --merged | grep -v '\\*' | xargs -n 1 git branch -d"
	doff = reset head^
	done = !git fetch && git rebase origin/master && git checkout master && git merge @{-1} && git push
	ds = diff --stat=160,120
	dt = difftool
	dump = cat-file -p
	extend = commit -v --amend --no-edit
	fa = fetch --all
	fb = "!f() { git branch -a --contains $1; }; f"
	fc = "!f() { git log --pretty=oneline-details --decorate --date=short -S$1; }; f"
	ff = merge --ff-only
	filelog = log -u
	file-trail = log --follow -p -w
	fix = "!_() { c=$(git rev-parse $1) && git commit --fixup $c && git diff-index --quiet HEAD; s=$?; [ $s != 0 ] && git stash; git -c core.editor=cat rebase -i --autosquash $c~; [ $s != 0 ] && git stash pop; }; _"
	fixup = !sh -c 'git commit -m \"fixup! $(git log -1 --format='\\''%s'\\'' $@)\"' -
	fl = log -u
	flip = !branch=$(git name-rev --name-only HEAD); git rebase --quiet --onto HEAD~2 HEAD~1 HEAD; git cherry-pick ORIG_HEAD~1; git update-ref refs/heads/$branch $(git rev-parse HEAD); git checkout --quiet $branch
	flip-last = !branch=$(git name-rev --name-only HEAD); git rebase --quiet --onto HEAD~2 HEAD~1 HEAD; git cherry-pick ORIG_HEAD~1; git update-ref refs/heads/$branch $(git rev-parse HEAD); git checkout --quiet $branch
	fm = "!f() { git log --pretty=oneline-details --decorate --date=short --grep=$1; }; f"
	ft = "!f() { git describe --always --contains $1; }; f"
	git = "!f() { git \"$@\"; }; f"
	graph = log --graph --pretty=oneline-details --abbrev-commit --date=relative
	go = checkout -B
	h = help
	hist = log --pretty=oneline-details --graph --date=short
	history = log --pretty=oneline-details --graph --date=short
	home = rev-parse --show-toplevel
	ignore = update-index --assume-unchanged
	ignored = !git ls-files -v | grep '^[[:lower:]]' | awk '{print $2}'
	ir = rebase -i origin/master
	irb = rebase --interactive
	l = log --pretty=oneline-details -n 20 --graph --abbrev-commit
	last = !git --no-pager log -1 HEAD --format=sha
	lc = log ORIG_HEAD.. --stat --no-merges
	lg = log --graph --pretty=oneline-details --abbrev-commit --date=relative
	llog = log --date=local
	ln = log --pretty=oneline-details
	log-graph = log --all --graph --decorate
	log-refs = log --all --graph --decorate --oneline --simplify-by-decoration --no-merges
	log-timeline = log --format=timeline
	log-local = log --oneline origin..HEAD
	log-fetched = log --oneline HEAD..origin/master
	lol = log --graph --decorate --pretty=oneline --abbrev-commit
	lola = log --graph --decorate --pretty=oneline --abbrev-commit --all
	lp = log --pretty=oneline-details --abbrev-commit --date=relative
	ls = log --oneline
	me = !git my-name
	m = merge -s recursive -X patience
	merge-branch = !git checkout master && git merge @{-1}
	merge-trail = log --ancestry-path --merges
	merged = branch --merged
	mm = merge --no-ff
	mt = mergetool
	my-email = config user.email
	my-name = config user.name
	new = !sh -c 'git log $1@{1}..$1@{0} "$@"'
	news = log -p HEAD@{1}..HEAD@{0}
	nevermind = !git reset --hard HEAD && git clean -d -f
	next = !git add . && git rebase --continue
	noff = merge --no-ff
	one = show -s --pretty='format:%h (%s)'
	oneline = log --oneline
	ours = "!f() { git co --ours $@ && git add $@; }; f"
	p = pair
	patch = log -p --no-walk # Generate patch file from a commit.
	pf = push --force-with-lease
	phh = push heroku HEAD
	phm = push heroku master
	pick = cherry-pick
	pickaxe = log -p -S
	poh = push origin HEAD
	pohf = push origin HEAD --force-with-lease
	pom = push origin master
	pr = !hub pull-request
	praise = blame
	precommit = diff --cached -w --word-diff=color --word-diff-regex='[^[:space:]<>]+'
	prestage = diff -w --word-diff=color
	prune = remote prune
	prune-all = !git remote | xargs -n 1 git remote prune
	publish = git flow feature publish
	pullff = pull --ff-only
	push = push --tags
	put = push origin HEAD
	r = remote
	rb = rebase
	rba = rebase --abort
	rbc = rebase --continue
	rbs = rebase --skip
	reb = "!r() { git rebase -i HEAD~$1; }; r"
	recursive-update = "!sh -c 'find \"${@:-.}\" -type d -name .git -exec dirname {} \\; -exec git --git-dir={} remote update \\;' _"
	regret = reset
	remotes = remote -v
	remove = rm
	reset-authors = commit --amend --reset-author -CHEAD
	retag = "!r() { git tag -d $1 && git push origin :refs/tags/$1 && git tag $1; }; r"
	review = diff master..HEAD
	reword = commit -v --amend --only
	rewrite = rebase -i
	rh = reset --hard
	ri = rebase --interactive
	rlog = !sh -c 'git log --color \"$@\" | fmt -s -w 79 | less -FRSX' _
	rmbranch = "!f(){ git branch -d ${1} && git push origin --delete ${1}; };f"
	root = rev-parse --show-toplevel
	ru = remote update --prune
	s = status -s
	search = log --pretty=oneline-details -S
	sh = show
	sha1 = "!sh -c 'git rev-parse --short ${1:-HEAD}' --"
	sho = show
	shove = push origin HEAD
	sl = shortlog
	ski = stash --keep-index
	skip = rebase --skip
	sm = submodule
	sma = submodule add
	smu = submodule update --init --recursive
	snapshot = !git stash save "snapshot: $(date)" && git stash apply "stash@{0}"
	sq = !sh -c 'git commit -m \"squash! $(git log -1 --format='\\''%s'\\'' $@)\"' -
	squash = !sh -c 'git commit -m \"squash! $(git log -1 --format='\\''%s'\\'' $@)\"' -
	st = status
	sta = stash
	staged = diff --staged
	stashes = stash list
	stat = status
	stl = stash list
	stp = stash pop
	sub = submodule
	summary = status -u -s
	svn-pull = !git svn fetch && git svn rebase
	svn-push = !git svn dcommit
	swap = !branch=$(git name-rev --name-only HEAD); git rebase --quiet --onto HEAD~2 HEAD~1 HEAD; git cherry-pick ORIG_HEAD~1; git update-ref refs/heads/$branch $(git rev-parse HEAD); git checkout --quiet $branch
	tags = tag -l
	theirs = "!f() { git co --theirs $@ && git add $@; }; f"
	today = log --stat --since='12am' --graph --pretty=oneline-details --abbrev-commit --date=relative
	today-all = log --all --since='12am' --graph --pretty=oneline-details --abbrev-commit --date=relative
	tr = log --graph --oneline --decorate --color
	tree = log --graph --oneline --decorate --color --all
	trust = !mkdir -p .git/safe
	type = cat-file -t
	uncommit = reset --soft HEAD^
	undo = '!f() { git reset --hard $(git rev-parse --abbrev-ref HEAD)@{${1-1}}; }; f'
	unignore = update-index --no-assume-unchanged
	unmerge = reset --hard ORIG_HEAD
	unmerged = branch --no-merged
	unpushed = !"PROJ_BRANCH=$(git symbolic-ref HEAD | sed 's|refs/heads/||') && git log origin/$PROJ_BRANCH..HEAD"
	unpulled = !"PROJ_BRANCH=$(git symbolic-ref HEAD | sed 's|refs/heads/||') && git fetch && git log HEAD..origin/$PROJ_BRANCH"
	unstage = reset HEAD --
	unstash = stash pop
	untrack = rm -r --cached
	up = !git fetch origin && git rebase origin/master
	update = !git fetch origin && git rebase origin/master
	wd = diff --word-diff="color"
	wdc = diff --word-diff="color" --cached
	wdiff = diff --word-diff=color --word-diff-regex=[a-zA-Z_0-9]+
	what = show -w
	whatis = show -s --pretty=oneline-details --date=short
	whatsnew = log origin/master@{1}..origin/master@{0}
	which-branches-contain = branch -a --contains
	which-tags-contain = name-rev --name-only
	who = shortlog -s --
	wipe = !git reset --hard; git clean -fd
